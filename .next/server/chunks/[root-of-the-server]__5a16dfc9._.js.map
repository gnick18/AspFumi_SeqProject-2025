{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///Users/gnickles/Desktop/AspFumi_Site/src/lib/geocoding.ts"],"sourcesContent":["// This is a reusable, server-side function to get coordinates for a given location.\n\nexport async function getCoordinates(city: string, state: string, country: string): Promise<{ lat: number; lng: number; matchLevel: string } | null> {\n    const queries = [`${city}, ${state}, ${country}`, `${city}, ${country}`, `${state}, ${country}`, country].filter(q => q.trim() !== ',' && q.trim().length > 1);\n    for (const query of queries) {\n        try {\n            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&accept-language=en&limit=1`;\n            const response = await fetch(url, { headers: { 'User-Agent': 'Aspergillus Community Sequencing Project' } });\n            if (response.ok) {\n                const data = await response.json();\n                if (data && data.length > 0) {\n                    const result = data[0];\n                    let matchLevel = 'country';\n                    const addressType = result.addresstype;\n                    if (['city', 'town', 'village', 'hamlet'].includes(addressType)) {\n                        matchLevel = 'city';\n                    } else if (['state', 'province', 'region', 'county'].includes(addressType)) {\n                        matchLevel = 'state';\n                    }\n                    return { lat: parseFloat(result.lat), lng: parseFloat(result.lon), matchLevel };\n                }\n            }\n        } catch (error) { console.error(`Geocoding error for query \"${query}\":`, error); }\n    }\n    return null;\n}\n"],"names":[],"mappings":"AAAA,oFAAoF;;;;;AAE7E,eAAe,eAAe,IAAY,EAAE,KAAa,EAAE,OAAe;IAC7E,MAAM,UAAU;QAAC,GAAG,KAAK,EAAE,EAAE,MAAM,EAAE,EAAE,SAAS;QAAE,GAAG,KAAK,EAAE,EAAE,SAAS;QAAE,GAAG,MAAM,EAAE,EAAE,SAAS;QAAE;KAAQ,CAAC,MAAM,CAAC,CAAA,IAAK,EAAE,IAAI,OAAO,OAAO,EAAE,IAAI,GAAG,MAAM,GAAG;IAC5J,KAAK,MAAM,SAAS,QAAS;QACzB,IAAI;YACA,MAAM,MAAM,CAAC,yDAAyD,EAAE,mBAAmB,OAAO,2BAA2B,CAAC;YAC9H,MAAM,WAAW,MAAM,MAAM,KAAK;gBAAE,SAAS;oBAAE,cAAc;gBAA2C;YAAE;YAC1G,IAAI,SAAS,EAAE,EAAE;gBACb,MAAM,OAAO,MAAM,SAAS,IAAI;gBAChC,IAAI,QAAQ,KAAK,MAAM,GAAG,GAAG;oBACzB,MAAM,SAAS,IAAI,CAAC,EAAE;oBACtB,IAAI,aAAa;oBACjB,MAAM,cAAc,OAAO,WAAW;oBACtC,IAAI;wBAAC;wBAAQ;wBAAQ;wBAAW;qBAAS,CAAC,QAAQ,CAAC,cAAc;wBAC7D,aAAa;oBACjB,OAAO,IAAI;wBAAC;wBAAS;wBAAY;wBAAU;qBAAS,CAAC,QAAQ,CAAC,cAAc;wBACxE,aAAa;oBACjB;oBACA,OAAO;wBAAE,KAAK,WAAW,OAAO,GAAG;wBAAG,KAAK,WAAW,OAAO,GAAG;wBAAG;oBAAW;gBAClF;YACJ;QACJ,EAAE,OAAO,OAAO;YAAE,QAAQ,KAAK,CAAC,CAAC,2BAA2B,EAAE,MAAM,EAAE,CAAC,EAAE;QAAQ;IACrF;IACA,OAAO;AACX","debugId":null}},
    {"offset": {"line": 113, "column": 0}, "map": {"version":3,"sources":["file:///Users/gnickles/Desktop/AspFumi_Site/src/app/api/admin/metadata/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\n// IMPORT THE DATABASE DRIVER\nimport { neon, NeonQueryFunction } from '@neondatabase/serverless';\nimport { getCoordinates } from '@/lib/geocoding';\n\n// The interface for a row in our table. Note: 'id' is now a number.\ninterface LabMetadata {\n  id: number;\n  [key: string]: unknown; \n}\n\n// --- NEW: Database-powered seeding function ---\n// This function will only run if the database table is empty.\nasync function seedInitialData(sql: NeonQueryFunction<false, false>) {\n  const adminLabs = [\n    { lab_name: 'Keller Lab', institution: 'University of Wisconsin-Madison', city: 'Madison', state: 'WI', country: 'United States', contact_name: 'Nancy Keller', contact_email: 'npkeller@wisc.com', research_use: 'Medical microbiology', comments: 'This is a pre-seeded admin lab entry.', latitude: 43.0731, longitude: -89.4012, match_level: 'city' },\n    { lab_name: 'Rokas Lab', institution: 'Vanderbilt University', city: 'Nashville', state: 'TN', country: 'United States', contact_name: 'Antonis Rokas', contact_email: 'admin@example.com', research_use: 'Fungal evolution and pathogenesis.', comments: 'This is a pre-seeded admin lab entry.', latitude: 36.1627, longitude: -86.7816, match_level: 'city' },\n    { lab_name: 'Barber Lab', institution: 'Friedrich Schiller University Jena', city: 'Jena', state: '', country: 'Germany', contact_name: 'Amelia Barber', contact_email: 'amelia.barber@uni-jena.de', research_use: 'Fungal genetics and pathogenesis.', comments: 'This is a pre-seeded admin lab entry.', latitude: 50.9271, longitude: 11.5892, match_level: 'city' },\n    { lab_name: 'Gluck-Thaler Lab', institution: 'University of Wisconsin-Madison', city: 'Madison', state: 'WI', country: 'United States', contact_name: 'Emile Gluck-Thaler', contact_email: 'gluckthaler@wisc.edu', research_use: 'Plant pathology fungal genomics', comments: 'This is a pre-seeded admin lab entry.', latitude: 43.0731, longitude: -89.4012, match_level: 'city' }\n  ];\n\n  // Insert each admin lab into the database table\n  for (const lab of adminLabs) {\n    await sql`\n      INSERT INTO lab_submissions (\n        lab_name, institution, city, state, country, contact_name, contact_email, \n        research_use, comments, latitude, longitude, match_level\n      ) VALUES (\n        ${lab.lab_name}, ${lab.institution}, ${lab.city}, ${lab.state}, ${lab.country}, \n        ${lab.contact_name}, ${lab.contact_email}, ${lab.research_use}, ${lab.comments},\n        ${lab.latitude}, ${lab.longitude}, ${lab.match_level}\n      );\n    `;\n  }\n}\n\n// --- API Methods ---\n\n// GET: Fetches all lab submissions from the database\nexport async function GET() {\n  const sql = neon(process.env.POSTGRES_URL!);\n  \n  try {\n    // Check if the table is empty\n    const countResult = await sql`SELECT COUNT(*) FROM lab_submissions`;\n    const rowCount = parseInt(countResult[0].count as string, 10);\n    \n    // If it's empty, seed it with the initial admin labs\n    if (rowCount === 0) {\n      await seedInitialData(sql);\n    }\n\n    // Fetch and return all submissions\n    const submissions = await sql`SELECT * FROM lab_submissions ORDER BY timestamp DESC`;\n    return NextResponse.json({ submissions });\n\n  } catch (error) {\n      console.error(\"Database GET Error:\", error);\n      return NextResponse.json({ error: \"Failed to fetch data from database.\" }, { status: 500 });\n  }\n}\n\n// PUT: Updates an existing lab submission in the database\n// --- THIS IS THE FUNCTION WE ARE FIXING ---\nexport async function PUT(request: NextRequest) {\n  try {\n    const updatedRow: LabMetadata = await request.json();\n    const sql = neon(process.env.POSTGRES_URL!);\n    \n    // 2. RE-GEOCODE THE LOCATION\n    // Before we update, we call our shared function to get fresh coordinates for the new address.\n    const coordinates = await getCoordinates(\n        updatedRow.city as string, \n        updatedRow.state as string, \n        updatedRow.country as string\n    );\n\n    // 3. UPDATE THE DATABASE WITH THE NEW COORDINATES\n    // The SQL query now uses the newly fetched coordinates, not the old ones from the form.\n    await sql`\n      UPDATE lab_submissions\n      SET \n        lab_name = ${updatedRow.lab_name as string}, institution = ${updatedRow.institution as string}, city = ${updatedRow.city as string},\n        state = ${updatedRow.state as string}, country = ${updatedRow.country as string}, contact_name = ${updatedRow.contact_name as string},\n        contact_email = ${updatedRow.contact_email as string}, research_use = ${updatedRow.research_use as string},\n        comments = ${updatedRow.comments as string}, \n        latitude = ${coordinates?.lat || null},      -- Use the new latitude\n        longitude = ${coordinates?.lng || null},     -- Use the new longitude\n        match_level = ${coordinates?.matchLevel || 'none'} -- Use the new match level\n      WHERE id = ${updatedRow.id};\n    `;\n    \n    // We create a final version of the row to send back to the admin page,\n    // ensuring it has the newly calculated coordinates so the UI updates instantly.\n    const finalUpdatedRow = {\n        ...updatedRow,\n        latitude: coordinates?.lat || null,\n        longitude: coordinates?.lng || null,\n        match_level: coordinates?.matchLevel || 'none',\n    };\n\n    return NextResponse.json({ success: true, updatedRow: finalUpdatedRow });\n  } catch(error) {\n    console.error(\"Database PUT Error:\", error);\n    return NextResponse.json({ error: \"Failed to update data in database.\" }, { status: 500 });\n  }\n}\n\n// The DELETE function remains the same.\nexport async function DELETE(request: NextRequest) {\n    try {\n        const { id } = await request.json();\n        const sql = neon(process.env.POSTGRES_URL!);\n        await sql`DELETE FROM lab_submissions WHERE id = ${id}`;\n        return NextResponse.json({ success: true });\n    } catch(error) {\n        console.error(\"Database DELETE Error:\", error);\n        return NextResponse.json({ error: \"Failed to delete data from database.\" }, { status: 500 });\n    }\n}"],"names":[],"mappings":"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","debugId":null}}]
}